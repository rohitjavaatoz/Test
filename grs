package com.verizon.ucm.interactionmanagement.services.search.emailmessages;


import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;

import com.verizon.ucm.interactionmanagement.response.dashboard.ProgressTrackerSummaryResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;

import com.verizon.ucm.interactionmanagement.entity.MessagesEntity;
import com.verizon.ucm.interactionmanagement.handler.DashBoardSummaryHandler;
import com.verizon.ucm.interactionmanagement.repository.EmailMessageLabelsRepository;
import com.verizon.ucm.interactionmanagement.repository.EmailMessageSearchRepository;
import com.verizon.ucm.interactionmanagement.specifications.EmailMessageFilterCriteria;
import com.verizon.ucm.interactionmanagement.specifications.EmailMessageSearchCriteria;
import com.verizon.ucm.interactionmanagement.util.DateTimeConversionUtil;
import com.verizon.ucm.interactionmanagement.util.SearchConstants;

@Service
public class DashBoardProgressTrackerSummaryService {

	private static final Logger LOGGER = LoggerFactory.getLogger(DashBoardProgressTrackerSummaryService.class);

	@Autowired
	private EmailMessageSearchRepository emailMessageSearchRepository;

	@Autowired
	private DashBoardSummaryHandler dashBoardSummaryHandler;
	
	@Autowired
	private EmailMessageLabelsRepository emailMessageLabelsRepository;

	public List<ProgressTrackerSummaryResponse> getDashBoardProgressTrackerSummary(UUID uuid) {

		LOGGER.info(
				"DashBoardProgressTrackerSummaryService# getDashBoardProgressTrackerSummary#: inside getDashBoardProgressTrackerSummary: uuid={}",
				uuid);
		List<ProgressTrackerSummaryResponse> progressTrackerMap = null;

		try {
			Instant startTime = Instant.now();
			CompletableFuture<Map<String, Long>> autoProcessedFuture = CompletableFuture
					.supplyAsync(() -> searchDashBoardProgressTrackerSummary(SearchConstants.AUTOMATICALLY_PROCESSED));
			
			CompletableFuture<Map<String, Long>> unProcessedMapFuture = CompletableFuture
					.supplyAsync(() ->  searchDashBoardProgressTrackerSummary(SearchConstants.UNPROCESSED));
			
			CompletableFuture<Void> combinedProgressTrackerFuture = CompletableFuture
					.allOf(autoProcessedFuture, unProcessedMapFuture);
			
			combinedProgressTrackerFuture.get();

			Map<String, Long> autoProcessedMap = null;
			if (autoProcessedFuture.isDone()) {
				autoProcessedMap = autoProcessedFuture.get();
			}

			Map<String, Long> unProcessedMap = null;
			if (unProcessedMapFuture.isDone()) {
				unProcessedMap = unProcessedMapFuture.get();
			}

			Set<String> dayMonthKeys = null;
			if ((autoProcessedMap != null && !autoProcessedMap.isEmpty())
					|| (unProcessedMap != null && !unProcessedMap.isEmpty())) {
				dayMonthKeys = new TreeSet<>();
				dayMonthKeys.addAll(autoProcessedMap != null ? autoProcessedMap.keySet() : null);
				dayMonthKeys.addAll(unProcessedMap != null ? unProcessedMap.keySet() : null);
			}

			if (dayMonthKeys != null && !dayMonthKeys.isEmpty()) {
				progressTrackerMap = prepareProgressTrackerResponse(dayMonthKeys, autoProcessedMap, unProcessedMap);
			}
			
			LOGGER.info("DashBoardSummaryService# getDashBoardSummary#:end:successfully prepared ProgressTracker dashboard summary for uuid={}, time_taken={}",
					uuid, Duration.between(startTime, Instant.now()).toMillis());

		} catch (InterruptedException ie) {
			LOGGER.error("DashBoardProgressTrackerSummaryService# getDashBoardProgressTrackerSummary#: Exception occurred {},uuid:{}",
					ie, uuid);
			Thread.currentThread().interrupt();
		} catch (Exception e) {
			LOGGER.error("DashBoardProgressTrackerSummaryService# getDashBoardProgressTrackerSummary#: Exception occurred while building ProgressTrackerResponse object: uuid={}, exception={}",
					uuid, e.getMessage());
		}

		return progressTrackerMap;
	}
	
	private Map<String, Long> searchDashBoardProgressTrackerSummary(String dashBoardStatusSearch) {

		List<Object[]> emailListCount=new ArrayList<Object[]>();

		if (SearchConstants.AUTOMATICALLY_PROCESSED.equalsIgnoreCase(dashBoardStatusSearch)) {
			emailListCount= emailMessageSearchRepository.getAutoProcessedEmailsForPastOneWeek();

		} else if (SearchConstants.UNPROCESSED.equalsIgnoreCase(dashBoardStatusSearch)) {
			emailListCount= emailMessageSearchRepository.getUnProcessedEmailsForPastOneWeek();
		}

		Instant startTime = Instant.now();
		LOGGER.info(
				"DashBoardSummaryService# getDashBoardSummary#:end:successfully prepared ProgressTracker-XXXXXXXXXXXXXXXXXXXXX dashboard summary for time_taken={}",
				Duration.between(startTime, Instant.now()).toMillis());
		return createProgressTrackerMap(emailListCount);
	}

	private Map<String, Long> createProgressTrackerMap(List<Object[]> searchResponse) {

		Map<String, Long> map = new HashMap<>();
		if (searchResponse != null && !searchResponse.isEmpty()) {
			for (Object[] obj:searchResponse ) {
				String dayMonth = obj[0].toString();
				map.put(dayMonth, Long.valueOf(obj[1].toString()));
			}
		}
		return map;
	}
	
	private List<ProgressTrackerSummaryResponse> prepareProgressTrackerResponse(Set<String> keys,
			Map<String, Long> autoProcessedMap, Map<String, Long> unProcessedMap) {
		List<ProgressTrackerSummaryResponse> progressTrackerSummaryResponseList=new ArrayList<>();

		Map<String, Map<String, Long>> map = new LinkedHashMap<>();
		for (String key : keys) {
			if (key != null && !map.containsKey(key)) {
				ProgressTrackerSummaryResponse progressTrackerSummaryResponse=new ProgressTrackerSummaryResponse();
				progressTrackerSummaryResponse.setxValue(key);
				progressTrackerSummaryResponse.setAutomaticallyProcessed(autoProcessedMap.get(key) != null ? autoProcessedMap.get(key) : 0L );
				progressTrackerSummaryResponse.setUnProcessed(unProcessedMap.get(key) != null ? unProcessedMap.get(key) : 0L);
				progressTrackerSummaryResponseList.add(progressTrackerSummaryResponse);
			}
		}
		return progressTrackerSummaryResponseList;
	}

}
======================================
import org.junit.Test;
import org.mockito.Mockito;

import java.time.Duration;
import java.time.Instant;
import java.util.*;
import java.util.concurrent.CompletableFuture;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

public class DashBoardProgressTrackerSummaryServiceTest {

    @Test
    public void testGetDashBoardProgressTrackerSummary_Success() throws Exception {
        // Mock dependencies
        EmailMessageSearchRepository searchRepository = Mockito.mock(EmailMessageSearchRepository.class);
        DashBoardSummaryHandler summaryHandler = Mockito.mock(DashBoardSummaryHandler.class);
        EmailMessageLabelsRepository labelsRepository = Mockito.mock(EmailMessageLabelsRepository.class);

        // Set up the service and inject mocks
        DashBoardProgressTrackerSummaryService service = new DashBoardProgressTrackerSummaryService();
        service.emailMessageSearchRepository = searchRepository;
        service.dashBoardSummaryHandler = summaryHandler;
        service.emailMessageLabelsRepository = labelsRepository;

        // Mocking behavior for repositories
        List<Object[]> mockedResponse = Arrays.asList(new Object[]{"2023-12-25", 5L}, new Object[]{"2023-12-26", 8L});
        when(searchRepository.getAutoProcessedEmailsForPastOneWeek()).thenReturn(mockedResponse);
        when(searchRepository.getUnProcessedEmailsForPastOneWeek()).thenReturn(mockedResponse);

        // Call the method under test
        UUID uuid = UUID.randomUUID();
        List<ProgressTrackerSummaryResponse> result = service.getDashBoardProgressTrackerSummary(uuid);

        // Assertions and verifications
        assertNotNull(result);
        assertEquals(2, result.size());
        verify(searchRepository, times(1)).getAutoProcessedEmailsForPastOneWeek();
        verify(searchRepository, times(1)).getUnProcessedEmailsForPastOneWeek();
    }

    @Test
    public void testGetDashBoardProgressTrackerSummary_EmptyResponse() throws Exception {
        // Mock dependencies
        EmailMessageSearchRepository searchRepository = Mockito.mock(EmailMessageSearchRepository.class);
        DashBoardSummaryHandler summaryHandler = Mockito.mock(DashBoardSummaryHandler.class);
        EmailMessageLabelsRepository labelsRepository = Mockito.mock(EmailMessageLabelsRepository.class);

        // Set up the service and inject mocks
        DashBoardProgressTrackerSummaryService service = new DashBoardProgressTrackerSummaryService();
        service.emailMessageSearchRepository = searchRepository;
        service.dashBoardSummaryHandler = summaryHandler;
        service.emailMessageLabelsRepository = labelsRepository;

        // Mocking behavior for repositories to return empty response
        when(searchRepository.getAutoProcessedEmailsForPastOneWeek()).thenReturn(Collections.emptyList());
        when(searchRepository.getUnProcessedEmailsForPastOneWeek()).thenReturn(Collections.emptyList());

        // Call the method under test
        UUID uuid = UUID.randomUUID();
        List<ProgressTrackerSummaryResponse> result = service.getDashBoardProgressTrackerSummary(uuid);

        // Assertions and verifications
        assertNotNull(result);
        assertEquals(0, result.size());
        verify(searchRepository, times(1)).getAutoProcessedEmailsForPastOneWeek();
        verify(searchRepository, times(1)).getUnProcessedEmailsForPastOneWeek();
    }

    // Add more test cases to cover different scenarios and lines in the service method

    @Test
    public void testSearchDashBoardProgressTrackerSummary_AutoProcessed() {
        // Test the search method with "AUTOMATICALLY_PROCESSED" status
        // Mock dependencies
        EmailMessageSearchRepository searchRepository = Mockito.mock(EmailMessageSearchRepository.class);
        DashBoardSummaryHandler summaryHandler = Mockito.mock(DashBoardSummaryHandler.class);
        EmailMessageLabelsRepository labelsRepository = Mockito.mock(EmailMessageLabelsRepository.class);

        // Set up the service and inject mocks
        DashBoardProgressTrackerSummaryService service = new DashBoardProgressTrackerSummaryService();
        service.emailMessageSearchRepository = searchRepository;
        service.dashBoardSummaryHandler = summaryHandler;
        service.emailMessageLabelsRepository = labelsRepository;

        // Mocking behavior for "AUTOMATICALLY_PROCESSED" search
        List<Object[]> mockedResponse = Collections.singletonList(new Object[]{"2023-12-25", 5L});
        when(searchRepository.getAutoProcessedEmailsForPastOneWeek()).thenReturn(mockedResponse);

        // Call the method under test
        Map<String, Long> result = service.searchDashBoardProgressTrackerSummary(SearchConstants.AUTOMATICALLY_PROCESSED);

        // Assertions and verifications
        assertNotNull(result);
        assertEquals(1, result.size());
        verify(searchRepository, times(1)).getAutoProcessedEmailsForPastOneWeek();
    }

    // Add more test cases for each method and condition in the service
}
